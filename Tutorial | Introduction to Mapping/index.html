
<!-- /*
*    Copyright 2018 Misty Robotics, Inc.

*    Licensed under the Apache License, Version 2.0 (the "License");
*    you may not use this file except in compliance with the License.
*    You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
*    Unless required by applicable law or agreed to in writing, software
*    distributed under the License is distributed on an "AS IS" BASIS,
*    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or 
implied.
*    See the License for the specific language governing permissions and
*    limitations under the License.
*/ -->

<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Tutorial | Introduction to Mapping</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<!-- Include references to a CDN for the Axios library and the local path where lightSocket.js is saved in the <head> of your document -->
	<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
	<script src="../Tools/javascript/lightSocket.js"></script>
</head>
<body>
	<!--Create a canvas element to hold the graphic map-->
	<canvas id="mapCanvas" class="col-md-9 col-sm-12 mr-2"></canvas>
	<script>
		/* GLOBALS */

		// Declare a global variable ip.
		// Set its value to Misty's IP address.
		const ip = "<robotipaddress>";
		// The pixelsPerGrid variable is used in drawMap().
		// Adjust this value to change the size of the map.
		const pixelsPerGrid = 10;
		
		// Tracks whether we are subscribed to SelfState events.
		let subscribed = false;
		// Track whether Misty is ready to start mapping.
		let ready = false;
		// Track when Misty is in the process of mapping.
		let mapping = false; 

		// Create a new instance of LightSocket.
		// Pass in ip and a the name of the callback
		// function to run when the socket opens.
		let socket = new LightSocket(ip, openCallback);

		/*TIMEOUT */

        // Define a helper function called sleep that 
		// can pause code execution for a period of time.
		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		/* CALLBACKS */

		// Define the callback function that
		// executes when the socket opens.
		function openCallback() {
			// Subscribe to SelfState events.
			subscribeSelfState();
			startMapping();
		}
		// Define the _SelfState() callback function. 
		// This function handles SelfState event data.
		function _SelfState(data) {
			// Update subscribed to true.   
			if (!subscribed) {
				subscribed = true;
				// Print a message to indicate the subscription
				// is established and Misty is obtaining pose.
				console.log("1 - Subscribed to SelfState, getting pose");
			}
			// Update global variables according to SLAM status.
			// Use try, catch to handle exceptions.
			try {
				// Ensure the data contains a relevant message by checking 
    			// that the value of data.message is not a string
				if (typeof data.message != "string") {

					// Assign the status of the SLAM system to runMode.
					let runMode = data.message.runMode;
					// Print the value of runMode to the console.
					console.log("runMode: " + runMode);
					// Check the value of runMode. 
					// If "Ready", break and do nothing.
					// If "Exploring", pose is obtained. 
					// Misty can collect map data.
					switch (runMode) {
						case "Ready":
							break
						case "Exploring":
							ready = true;
							break
						case "Paused":
							mapping = false;
							break
					}
				}
			}
			catch (e) {
			}
		}

		/* WEBSOCKET SUBSCRIPTION FUNCTIONS */

		// This function subscribes to SelfState events.
		function subscribeSelfState() {
			// Call socket.Subscribe() with the following
			// arguments to get information about the status
			// of Misty's SLAM system from SelfState events.
			socket.Subscribe("SlamStatus", "SelfState", 5000, null, null, null, "slamStatus", _SelfState);
		}

		// Define unsubscribeSelfState()
		function unsubscribeSelfState() {
			socket.Unsubscribe("SlamStatus");
		}


		/* COMMANDS */

		// Define the startMapping() function
		async function startMapping() {
			// sleep() for 500 milliseconds 
    		// for as long as subscribed is false.
			while (!subscribed) {
				await sleep(500);
			}
			// update state
			mapping = true;
    		// Use axios.post() to send a POST request 
    		// to the endpoint for the SlamStartMapping command.
			axios.post("http://" + ip + "/api/alpha/slam/map/start");
			getMap();
		}

		// Define getMap() as an asynchronous function. 
		// This function gathers map data as Misty roams 
		// her environment.
		async function getMap() {
			// sleep() for 500 milliseconds 
    		// for as long as ready is false.
			while (!ready) {
				await sleep(500);
			}
			// Print a message that pose is obtained.
			console.log("2 - Pose obtained, starting mapping");
			// Use an alert to pause execution of the program.
			// This gives you time to drive Misty around and
			// gather map data. Execution of the program
			// continues when you click OK.
			alert("Head over to the API explorer and drive Misty around the room to gather map data. Once finished, hit ok to proceed.");
			// Use axios.post() to send a POST request to the endpoint for the SlamStopMapping command.
			axios.post("http://" + ip + "/api/alpha/slam/map/stop");
			// Pause execution while mapping is true.
			while (mapping) {
				await sleep(500);
			}

    		// Print a message to that mapping has stopped 
    		// and the map is being obtained.
			console.log("3 - Mapping has stopped, obtaining map");

			// Use axios.get() to send a GET request 
			// to the endpoint for the SlamGetRawMap command.
			// Use then() to call unsubscribeSelfState() and processMap().
			axios.get("http://" + ip + "/api/alpha/slam/map/raw")
				.then((data) => {
					unsubscribeSelfState();
					processMap(data);
				})
				.catch((err) => {
					console.log(err);
				})
		}
		// Define processMap()
		function processMap(res) {
    		// Print a message that we have received the map data.
			console.log("4 - Recieved map, processing map data");
			// Store the map data.
			let data = res.data;
			drawMap(data)
		}

		/*** Map-drawing Code from API explorer ***/
		// This function is copied from the API Explorer 
		// source code. It creates a graphic image of a
		// map from Misty's raw map data.
		function drawMap(data) {
			var canvas = document.getElementById("mapCanvas");
			var context = canvas.getContext("2d");
			canvas.width = (data[0].result.width - 1) * pixelsPerGrid;
			canvas.height = (data[0].result.height - 1) * pixelsPerGrid;
			context.scale(pixelsPerGrid, pixelsPerGrid);
			data[0].result.grid.reverse().forEach(function (item) { item.reverse(); });
			for (var currentX = data[0].result.height - 1; currentX >= 0; currentX--) {
				for (var currentY = data[0].result.width - 1; currentY >= 0; currentY--) {
					context.beginPath();
					context.lineWidth = 1;
					switch (data[0].result.grid[currentX][currentY]) {
						case 0:
							// "Unknown"
							context.fillStyle = 'rgba(133, 133, 133, 1.0)'; // '#858585';
							break;
						case 1:
							// "Open"
							context.fillStyle = 'rgba(255, 255, 255, 1.0)'; // '#FFFFFF';
							break;
						case 2:
							// "Occupied"
							context.fillStyle = 'rgba(42, 42, 42, 1.0)'; // '#2A2A2A';
							break;
						case 3:
							// "Covered"
							context.fillStyle = 'rgba(102, 0, 237, 1.0)'; // 'rgba(33, 27, 45, 0.5)'; // '#6600ED';
							break;
						default:
							context.fillStyle = '#ff9b9b';
							break;
					}
					context.rect(currentY - 1 * pixelsPerGrid, currentX - 1 * pixelsPerGrid, pixelsPerGrid, pixelsPerGrid);
					context.fill();
				}
			}
			alert("Skill finished! Successfully obtained and drew a map!");
		}

		// Open the connection to your robot.
		
		socket.Connect();
	</script>
</body>
</html>